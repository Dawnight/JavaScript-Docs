[TOC]
### 原型和原型链
#### 问题引出
+ 如何准确判断一个变量是数组类型？------ **instanceof**
    ```javascript
        var arr=[];
        arr instanceof Array;//true
        typeof arr;//object,typeof无法判断是否是数组
    ```

+ 写一个原型链继承的例子

```javascript
    function Elem(id){
        this.elem=document.getElementById(id);
    }

    Elem.prototype.html=function(val){
        var elem=this.elem;
        if(val){
            elem.innerHTML=val;
            return this;//返回整个对象，不return也行，返回的目的是为了链式操作
        }else{
            return elem.innerHTML;//返回当前的元素结构
        }
    }

    Elem.prototype.on=function(type,fn){
        var elem=this.elem;
        elem.addEventListener(type,fn)
    }

    var div1=new Elem('box');
    //console.log(div1.html());
    div1.html('<p>hello div-html</p>')
        .on('click',function(){ //链式操作
            alert('clicked');
        }).html('<p>javascript</p>')

```

```javascript
    不要这么写，这个例子只是方便理解原型链继承。
    function Animal(){
        this.eat=function(){
            console.log('animal eat')
        }
    }

    function Dog(){
        this.bark=function(){
            console.log('dog bark')
        }
    }

    Dog.prototype=new Animal();

    var hashiqi=new Dog();
```

+ 描述new一个对象的过程。

创建一个新对象。
this指向这个新对象。
执行代码，即对this赋值。
返回this。

+ zepto或其他框架源码中如何使用原型链？

阅读源码是高效提高技能的方式。
不能"埋头苦钻",有技巧在其中，网上搜索别人阅读的一些资料。
慕课网搜索"zepto设计和源码分析"或者"jQuery源码分析"



#### 构造函数
```javascript
    function Foo(name,age){
        this.name=name;
        this.age=age;
        this.class='class-1';
        //return this;//默认有这一行
    }
    var f=new Foo('zhangsan',20);
    var f1=new Foo('lisi',22);//可以通过new创建多个对象。
```

构造函数的return最好不要写.

#### 构造函数   - 扩展

+ var a = {};其实是 var a = new Object()的语法糖
+ var a = [];其实是 var a = new Array()的语法糖
+ function Foo(){...}其实是var Foo=new Function(...)
+ 使用instanceof判断一个函数是否是一个变量的构造函数

#### 原型规则和示例

五条原型规则，原型规则是学习原型链的基础


1.每一个函数，都有一个prototype属性,无论是自定义的，还是系统内置的。都有一个constructor指向它本身。<br/>
2.所有通过函数new出来的东西，这个东西都有一个__proto__<br/>指向这个函数的prototype,prototype:显式原型，__proto__:（隐式）原型。<br/>
3.当你想要使用一个对象（或者一个数组）的某个功能时：如果该对象本身具有这个功能，则直接使用；如果该对象本身没有这个功能，则去__proto__中找。<br/>
4.Array是函数，Object是函数，Function也是函数，大写的Function和小写的function不一样。


+ 所有的引用类型(数组，对象，函数)，都具有对象特性，即可自由扩展属性(除了"null"以外)。
+ 所有的引用类型(数组，对象，函数)，都有一个(--proto--)**隐式原型**属性，属性值是一个普通的对象，对象里边有浏览器定义好的属性。

+ 所有的函数，都有一个(prototype) **显式原型** 属性，属性值也是一个普通的对象。

+ 所有的引用类型(数组，对象，函数)，__ proto __属性值指向它的构造函数的"prototype"属性值。

```javascript
    var obj={};obj.a=100;
    var arr=[];arr.a=100;
    function fn(){}
    fn.a=100;
    
    console.log(obj.__proto__);
    console.log(arr.__proto__);
    console.log(fn.__proto__);//ƒ () { [native code] }
    
    console.log(fn.prototype);//constructor:ƒ fn()
    
    console.log(obj.__proto__===Object.prototype);//true
```

+  当试图得到一个引用类型的某个属性时，如果这个对象本身没有这个属性，那么会去它的__ proto __ **隐式原型**(即它的构造函数的prototype**显式原型**)中寻找。

```javascript
    //创建构造函数
    function Foo(name,age){
        this.name=name;
    }
    Foo.prototype.alertName=function(){
        alert(this.name);
    }
    //创建示例
    var f=new Foo('zhangsan');
    f.printName=function(){
        console.log(this.name)
    }
    //测试
    f.printName();
    f.alertName();
    f.toString();//要去f.__proto__.__proto__中去查找
```

```javascript
    var item;
    for(var item in f){
        //高级浏览器已经在for in中屏蔽了来自原型的属性
        //但是建议加上这个判断，保证程序的健壮性。
        if(f.hasOwnProperty(item)){
            console.log(item)
        }
    }
```

#### 原型链

#### instanceof
用于**判断引用类型**属于哪个**构造函数**的方法。
f instanceof Foo的判断逻辑：
f的__proto__一层一层往上，能否对应到Foo.prototype
再试着判断 f instanceof Object.