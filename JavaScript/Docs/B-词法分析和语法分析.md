# 词法分析和语法分析
# 1. 编译原理
### 1.1 **分词/词法分析(Tokenizing/Lexing)**
+ 这个过程将由字符组成的字符串分解成有意义的代码块，这些代码块被称为**词法单元(token)**。例如，`var a = 2;`，这段程序通常会被分解成为下面的这些词法单元: `var`，`a`，`=`，`2`，`;`空格是否会被当做词法单元，取决于空格在这门语言中是否有意义

> 分词(token)和词法分析(Lexing)之间的区别是非常微妙，晦涩的，主要差异在于词法单元的识别是通过**有状态**还是**无状态**的方式进行的。
> 简单来说，如果词法单元生成器在解释`a`是一个独立的词法单元还是其他的词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为**词法分析**

### 1.2 解析/语法分析(Parsing)
+ 这个过程是讲词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为**抽象语法树(Abstract Syntax Tree, AST)**
+ `var a = 2;`的抽象语法树中可能会有一个叫做`VariableDeclaration`的顶级节点，接下来是一个叫做`Identifier(它的值是a)`的子节点，以及一个叫做`AssignmentExpression`的子节点。`AssignmentExpression`节点有一个叫做`NumbericLiteral(它的值是2)`的子节点
+ 链接
    + [javascript的词法作用域](https://js8.in/2011/08/15/javascript的词法作用域/)
    + [静态作用域与动态作用域](https://zh.wikipedia.org/wiki/作用域#.E9.9D.99.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F.E4.B8.8E.E5.8A.A8.E6.80.81.E4.BD.9C.E7.94.A8.E5.9F.9F)
    + [Abstract Syntax Tree 抽象语法树简介](https://div.io/topic/1994)
    + [在线查看词法作用域的效果](https://astexplorer.net/)
    + [在线查看词法作用域的效果](http://resources.jointjs.com/demos/javascript-ast)
+ `var a = 2;`的抽象语法树的Tree示例
![`var a = 2;`的抽象语法树的Tree示例](../images/抽象语法树-Tree.png)
+ `var a = 2;`的抽象语法树的JSON示例
![`var a = 2;`的抽象语法树的JSON示例](../images/抽象语法树-JSON.png)

### 1.3 代码生成
+ 将AST转换成可执行代码的过程被称为代码生成，这个过程与语言，目标平台等信息息息相关。
+ 简单来说，就是有某种方法可以将`var a = 2;`的AST转化为一组机器指令，用来创建一个叫做a的变量(包括分配内存等)，并将一个值存储在a中。
+ 任何JavaScript代码片段在执行前都要进行编译(通常就在执行前)，因此JavaScript编译器首先会对`var a = 2;`这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

# 2. 理解作用域
### 2.1 参与作用域的对象
+ 引擎: 从头到尾负责整个JavaScript程序的编译及执行过程
+ 编译器: 负责语法分析及代码生成
+ 作用域: 负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### 2.2 引擎如何工作
+ 当我们看到`var a = 2;`这段程序时，我们会认为这是声明变量a并且赋值给a=2的语句。但是引擎不是这么看的。引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。
+ 以`var a = 2;`为例分解这段代码，看引擎是如何工作的
+ 编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成的时候，它对这段程序的处理方式会和预期的有所不同。
+ 可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括: `为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。`，然而这并不完全正确。
+ 事实上编译器会进行如下的处理
    + 遇到`var a`，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译。否则就会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。
    + 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理`a = 2`这个赋值操作。引擎运行时会首先询问作用域，在当前作用域集合中是否存在一个叫做a的变量。如果是，引擎就会使用这个变量。如果不是，引擎就会继续查找该变量。
    + 如果引擎最终找到了a变量，就会将2赋值给它。否则引擎就没有找到这个变量，那么就会示意抛出一个异常。`ReferenceError: a is not defined`
+ 总之，变量赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能找到就会给它赋值。

### 2.3 编译器
编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量a来判断它是否已经声明过，查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

+ 查找类型一共有LHS和RHS两种类型，分别代表左侧和右侧，其实就是赋值操作的左侧和右侧
+ 当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。
+ 更准确一点，RHS查询与简单地查找某个变量的值一样，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度来说，**RHS并不是真正意义上的赋值操作的右侧**，更准确地说是**非左侧**
+ 可以将RHS理解成`retrieve his source value(取到它的源值)`，这意味着**得到某某的值**
+ 考虑`console.log( a );`这段代码，其中对a的引用是一个RHS引用，因为这里a并没有赋予任何值，响应的是需要查找并取得a的值，这样才能传递给`console.log(..)`
+ 在考虑`a = 2;`这段代码，这里对a的引用则是LHS引用，因为实际上我们不关心当前的值是什么，只是想要为 ` = 2 `这个赋值操作找到一个目标

> LHS和RHS的含义是，**赋值操作的左侧和右侧**并不一定意味着就是**=赋值操作符的左侧或右侧**，赋值操作还有其他几种形式，因此在概念上最好将其理解为**赋值操作的目标是谁(LHS)**以及**谁是赋值操作的源头(RHS)**

+ 稍微复杂的例子，在这个例子中，最后一行`foo(...)`函数的调用需要对foo进行RHS引用，意味着`去找到foo的值，并把它给我`。并且`(...)`意味着foo的值需要被执行，因此它最好真的是一个函数类型的值。
+ 需要注意的是，代码中隐式的`a = 2;`操作可能很容易被忽略，这个操作发生在2被当做参数传递给`foo(...)`函数时，2会被分配给参数a，为了给参数a(隐式的)分配值，需要进行一次LHS查询。
+ 这里对a进行的RHS引用，并且将得到的值传递给`console.log(...)`，`console.log(...)`自身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检查得到的值中是否有一个叫做log的方法。
+ 最后，在概念上可以理解为在LHS和RHS之间通过对值2进行交互来将其传递进`log(...)`(通过变量a的RHS查询)，假设在`log(...)`函数的原生实现中它可以接受参数，在将2赋值给其中第一个参数之前，这个参数需要进行LHS引用查询。

```javascript
function foo(a) {
    console.log( a );
}
foo(2);
```
